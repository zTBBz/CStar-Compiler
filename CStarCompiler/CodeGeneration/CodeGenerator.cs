using System.Text;
using CStarCompiler.Parsing.Nodes;
using CStarCompiler.Parsing.Nodes.Modules;

namespace CStarCompiler.CodeGeneration;

public sealed class CodeGenerator
{
    private int _indentLevel;
    private string _currentModule = null!;
    
    // Стрингбилдеры для разных секций файла
    private readonly StringBuilder _sbHeader = new();
    private readonly StringBuilder _sbSource = new();
    private StringBuilder _currentSb = null!; // Текущий активный буфер

    // Анализатор и словари определений
    private MonomorphizationAnalyzer _analyzer = null!;
    
    // Кэш определений дженериков (AST узлы), чтобы генерировать их специализации по требованию
    private readonly Dictionary<string, StructDeclarationNode> _genericStructDefs = new();
    private readonly Dictionary<string, FunctionDeclarationNode> _genericFuncDefs = new();

    // Множество уже сгенерированных прототипов, чтобы не дублировать
    private readonly HashSet<string> _emittedTypedefs = [];

    public CompilationUnit GenerateUnit(ModuleNode module, MonomorphizationAnalyzer analyzer)
    {
        _analyzer = analyzer;
        _indentLevel = 0;
        _currentModule = module.ModuleName;
        
        _sbHeader.Clear();
        _sbSource.Clear();
        _genericStructDefs.Clear();
        _genericFuncDefs.Clear();
        _emittedTypedefs.Clear();

        // 1. Индексируем определения дженериков (сохраняем AST узлы)
        foreach (var decl in module.Declarations)
        {
            switch (decl)
            {
                case StructDeclarationNode { GenericParams.Count: > 0 } s:
                    _genericStructDefs[s.Name] = s;
                    break;
                case FunctionDeclarationNode { GenericParameters.Count: > 0 } f:
                    _genericFuncDefs[f.Name] = f;
                    break;
            }
        }

        // --- ГЕНЕРАЦИЯ ЗАГОЛОВКА (.h) ---
        _currentSb = _sbHeader;
        
        var guard = $"{_currentModule.ToUpper()}_H";
        Emit($"#ifndef {guard}");
        Emit($"#define {guard}");
        EmitNewLine();
        
        // Стандартные инклюды
        Emit("#include <stdbool.h>");
        Emit("#include <stdint.h>");
        Emit("#include <stddef.h>");
        EmitNewLine();

        // Импорты
        foreach (var import in module.Imports)
        {
            if (import.IsCLibrary) Emit($"#include <{import.ModuleName}.h>");
            else Emit($"#include \"{import.ModuleName}.h\"");
        }
        EmitNewLine();

        // 2. Typedefs (Forward Declarations) для ВСЕХ структур
        Emit("// --- Typedefs ---");
        GenerateAllTypedefs(module);
        EmitNewLine();

        // 3. Определения структур (Body)
        Emit("// --- Struct Definitions ---");
        GenerateStructDefinitions(module);
        EmitNewLine();

        // 4. Прототипы функций
        Emit("// --- Prototypes ---");
        GeneratePrototypes(module);
        
        EmitNewLine();
        Emit($"#endif // {guard}");
        
        // --- ГЕНЕРАЦИЯ ИСХОДНИКА (.c) ---
        _currentSb = _sbSource;

        Emit("// Generated by CStar Compiler");
        Emit($"// Module: {_currentModule}");
        EmitNewLine();
        
        Emit("#include <stdio.h>");
        Emit("#include <stdlib.h>");
        Emit("#include <string.h>");
        Emit($"#include \"{_currentModule}.h\"");
        EmitNewLine();

        // 5. Глобальные переменные
        Emit("// --- Globals ---");
        foreach (var decl in module.Declarations.OfType<FieldDeclarationNode>())
            GenField(decl, context: null, isGlobal: true);

        // 6. Реализация функций
        Emit("// --- Implementations ---");
        GenerateImplementations(module);

        return new(_currentModule, _sbHeader.ToString(), _sbSource.ToString());
    }

    // --- PHASE 2: TYPEDEFS ---
    private void GenerateAllTypedefs(ModuleNode module)
    {
        // 1. Обычные структуры
        foreach (var decl in module.Declarations.OfType<StructDeclarationNode>().Where(s => s.GenericParams.Count == 0))
        {
            var cName = GetCName(decl.Name);
            Emit($"typedef struct {cName} {cName};");
            _emittedTypedefs.Add(cName);
        }

        // 2. Специализации дженерик структур (из анализатора)
        foreach (var (structName, signatures) in _analyzer.StructUsages)
        {
            if (!_genericStructDefs.TryGetValue(structName, out _)) continue;

            foreach (var typeArgs in signatures)
            {
                var mangledName = GetMangledName(structName, typeArgs);
                if (_emittedTypedefs.Add(mangledName)) Emit($"typedef struct {mangledName} {mangledName};");
            }
        }
    }

    // --- PHASE 3: STRUCT DEFINITIONS ---
    private void GenerateStructDefinitions(ModuleNode module)
    {
        // 1. Обычные структуры
        foreach (var decl in module.Declarations.OfType<StructDeclarationNode>().Where(s => s.GenericParams.Count == 0))
            GenStruct(decl, context: null, overrideName: null);

        // 2. Специализированные структуры
        foreach (var (structName, signatures) in _analyzer.StructUsages)
        {
            if (!_genericStructDefs.TryGetValue(structName, out var def)) continue;

            foreach (var typeArgs in signatures)
            {
                var context = CreateTypeContext(def.GenericParams, typeArgs);
                var mangledName = GetMangledName(structName, typeArgs);
                GenStruct(def, context, mangledName);
            }
        }
    }

    // --- PHASE 4 & 6: FUNCTIONS ---
    private void GeneratePrototypes(ModuleNode module)
    {
        // Обычные
        foreach (var decl in module.Declarations.OfType<FunctionDeclarationNode>().Where(f => f.GenericParameters == null || f.GenericParameters.Count == 0))
            GenFunctionHead(decl, null, null, isPrototype: true);

        // Дженерик специализации
        foreach (var (funcName, signatures) in _analyzer.FunctionUsages)
        {
            if (!_genericFuncDefs.TryGetValue(funcName, out var def)) continue;
            foreach (var typeArgs in signatures)
            {
                var context = CreateTypeContext(def.GenericParameters!.Select(p=>p.Name).ToList(), typeArgs);
                var mangledName = GetMangledName(funcName, typeArgs);
                GenFunctionHead(def, context, mangledName, isPrototype: true);
            }
        }
    }

    private void GenerateImplementations(ModuleNode module)
    {
        // Обычные
        foreach (var decl in module.Declarations.OfType<FunctionDeclarationNode>().Where(f => f.GenericParameters == null || f.GenericParameters.Count == 0))
            GenFunctionBody(decl, null, null);

        // Дженерик специализации
        foreach (var (funcName, signatures) in _analyzer.FunctionUsages)
        {
            if (!_genericFuncDefs.TryGetValue(funcName, out var def)) continue;
            foreach (var typeArgs in signatures)
            {
                var context = CreateTypeContext(def.GenericParameters!.Select(p=>p.Name).ToList(), typeArgs);
                var mangledName = GetMangledName(funcName, typeArgs);
                GenFunctionBody(def, context, mangledName);
            }
        }
    }

    // --- GENERATION HELPERS ---

    private void GenStruct(StructDeclarationNode node, Dictionary<string, string>? context, string? overrideName)
    {
        var name = overrideName ?? GetCName(node.Name);
        Emit($"struct {name}");
        Emit("{");
        Indent();
        foreach (var member in node.Members.OfType<FieldDeclarationNode>())
        {
            GenField(member, context);
        }
        Unindent();
        Emit("};");
    }

    private void GenFunctionHead(FunctionDeclarationNode node, Dictionary<string, string>? context, string? overrideName, bool isPrototype)
    {
        var name = overrideName ?? GetCName(node.Name);
        var retType = MapType(node.ReturnType, context);
        
        EmitNoNewLine($"{retType} {name}(");
        
        for (var i = 0; i < node.Parameters.Count; i++)
        {
            var p = node.Parameters[i];
            Append($"{MapType(p.Type, context)} {p.Name}");
            if (i < node.Parameters.Count - 1) Append(", ");
        }
        
        Append(")");
        if (isPrototype) Append(";");
        EmitNewLine();
    }

    private void GenFunctionBody(FunctionDeclarationNode node, Dictionary<string, string>? context, string? overrideName)
    {
        GenFunctionHead(node, context, overrideName, isPrototype: false);
        
        if (node.Body != null) GenBlock(node.Body, context);
        else Emit("{ }");
        
        EmitNewLine();
    }

    private void GenBlock(BlockStatementNode block, Dictionary<string, string>? context)
    {
        if (block.IsCompileBlock)
        {
            Emit("/* compile block skipped */");
            return;
        }

        Emit("{");
        Indent();
        if (block.IsCCode) Emit("// --- CCode ---");
        
        foreach (var stmt in block.Statements) GenStatement(stmt, context);
        
        Unindent();
        Emit("}");
    }

    private void GenStatement(StatementNode stmt, Dictionary<string, string>? context)
    {
        switch (stmt)
        {
            case BlockStatementNode b: GenBlock(b, context); break;
            
            case VarDeclarationNode v:
                // Type Inference for 'var'
                string typeStr;
                if (v.Type.Name == "var")
                {
                    if (v.Initializer is LiteralExpressionNode lit)
                        typeStr = lit.Type switch {
                            "int" => "int32_t", "float" => "float", "bool" => "bool", "string" => "char*", _ => "int32_t"
                        };
                    else typeStr = "int32_t /* inferred failed */";
                }
                else typeStr = MapType(v.Type, context);
                
                var prefix = v.IsConst ? "const " : "";
                EmitNoNewLine($"{prefix}{typeStr} {v.Name}");
                if (v.Initializer != null)
                {
                    Append(" = ");
                    GenExpression(v.Initializer, context);
                }
                Append(";");
                EmitNewLine();
                break;

            case ReturnStatementNode r:
                EmitNoNewLine("return");
                if (r.Value != null)
                {
                    Append(" ");
                    GenExpression(r.Value, context);
                }
                Append(";");
                EmitNewLine();
                break;

            case IfStatementNode i:
                EmitNoNewLine("if (");
                GenExpression(i.Condition, context);
                Append(")");
                EmitNewLine();
                GenStatement(i.ThenBranch, context);
                if (i.ElseBranch != null)
                {
                    Emit("else");
                    GenStatement(i.ElseBranch, context);
                }
                break;

            case ExpressionStatementNode e:
                EmitNoNewLine("");
                GenExpression(e.Expression, context);
                Append(";");
                EmitNewLine();
                break;
        }
    }

    private void GenField(FieldDeclarationNode node, Dictionary<string, string>? context, bool isGlobal = false)
    {
        var type = MapType(node.Type, context);
        var name = isGlobal ? GetCName(node.Name) : node.Name;
        
        EmitNoNewLine($"{type} {name}");
        if (node.Initializer != null)
        {
            Append(" = ");
            GenExpression(node.Initializer, context);
        }
        Append(";");
        EmitNewLine();
    }

    private void GenExpression(ExpressionNode expr, Dictionary<string, string>? context)
    {
        switch (expr)
        {
            case LiteralExpressionNode l:
                if (l.Type == "string") Append($"\"{l.Value}\"");
                else if (l.Type == "char") Append($"'{l.Value}'");
                else if (l.Type == "bool") Append((bool)l.Value ? "true" : "false");
                else Append(l.Value?.ToString() ?? "0");
                break;

            case IdentifierExpressionNode id:
                Append(id.Name); // Здесь можно добавить проверку, не является ли это именем глобальной функции для манглинга
                break;

            case BinaryExpressionNode b:
                GenExpression(b.Left, context);
                Append($" {MapOperator(b.Operator)} ");
                GenExpression(b.Right, context);
                break;

            case UnaryExpressionNode u:
                Append(MapOperator(u.Operator));
                GenExpression(u.Operand, context);
                break;

            case CallExpressionNode call:
                // Обработка вызова дженерика
                if (call.Callee is TypeNode { Generics.Count: > 0 } tNode)
                {
                    // Это вызов специализированной функции: Func<int>(...) -> Func_int32_t(...)
                    // Нам нужно заманглить имя функции с текущими аргументами
                    
                    // Важно: аргументы дженерика сами могут зависеть от context! 
                    // Например, внутри Vector<T> вызываем Alloc<T>().
                    // Поэтому передаем context в GetMangledName.
                    
                    // Но GetMangledName ожидает конкретные типы (TypeNode). 
                    // Нам нужно "резолвить" дженерик параметры tNode перед манглингом.
                    var resolvedArgs = new List<TypeNode>();
                    foreach (var arg in tNode.Generics)
                    {
                        var mappedTypeStr = MapType(arg, context); // Получаем int32_t
                        // Создаем временный узел для манглера
                        resolvedArgs.Add(new(mappedTypeStr)); 
                    }
                    
                    Append(GetMangledName(tNode.Name, resolvedArgs));
                }
                else
                {
                    GenExpression(call.Callee, context);
                }

                Append("(");
                for (var i = 0; i < call.Arguments.Count; i++)
                {
                    GenExpression(call.Arguments[i], context);
                    if (i < call.Arguments.Count - 1) Append(", ");
                }
                Append(")");
                break;
                
            case MemberAccessExpressionNode m:
                GenExpression(m.Object, context);
                Append($".{m.MemberName}");
                break;

            case IndexExpressionNode idx:
                GenExpression(idx.Object, context);
                Append("[");
                GenExpression(idx.Index, context);
                Append("]");
                break;
            
            case TypeNode t:
                // Статический доступ к типу (например, в sizeof)
                Append(MapType(t, context));
                break;
        }
    }

    // --- TYPE MAPPING & MANGLING ---

    // Преобразует CStar тип в C тип с учетом контекста дженериков
    private string MapType(TypeNode type, Dictionary<string, string>? context)
    {
        // 1. Проверяем, не является ли тип параметром дженерика (T -> int32_t)
        if (context != null && context.TryGetValue(type.Name, out var concreteType))
        {
            // concreteType уже должен быть валидным C типом (напр. "int32_t" или "Vector_int32_t")
            // Но если у исходного типа были модификаторы массивов/указателей, их надо бы сохранить.
            // Упрощение: считаем, что T заменяется целиком.
            return concreteType;
        }

        // 2. Рекурсивный манглинг, если это дженерик тип: Vector<int> -> Vector_int32_t
        if (type.Generics is { Count: > 0 })
        {
            // Резолвим аргументы (они тоже могут быть T)
            var resolvedArgs = new List<TypeNode>();
            foreach (var arg in type.Generics)
            {
                var mappedArg = MapType(arg, context);
                resolvedArgs.Add(new(mappedArg)); // Хак: создаем TypeNode с уже готовым C именем
            }
            return GetMangledName(type.Name, resolvedArgs);
        }

        // 3. Базовые типы
        return MapPrimitive(type.Name);
    }
    
    // Создает уникальное имя: Vector + <int> -> Vector_int32_t
    private string GetMangledName(string baseName, List<TypeNode> typeArgs)
    {
        var sb = new StringBuilder(GetCName(baseName));
        foreach (var arg in typeArgs)
        {
            sb.Append('_');
            // Аргумент arg.Name здесь уже ожидается как C-тип (int32_t), полученный из MapType
            // Но нужно почистить его от символов, недопустимых в идентификаторах (*, space)
            sb.Append(arg.Name.Replace("*", "Ptr").Replace(" ", ""));
        }
        return sb.ToString();
    }

    private Dictionary<string, string> CreateTypeContext(List<string> paramsDecl, List<TypeNode> args)
    {
        var dict = new Dictionary<string, string>();
        for (var i = 0; i < paramsDecl.Count && i < args.Count; i++)
        {
            // Здесь MapType вызывается с null контекстом, так как аргументы вызова (args)
            // на верхнем уровне инстанцирования должны быть конкретными типами (int, float).
            // Если же мы внутри дженерика инстанцируем другой дженерик (Vector<T>),
            // то этот метод вызывается внутри процесса, где args уже подставлены.
            dict[paramsDecl[i]] = MapType(args[i], null);
        }
        return dict;
    }

    private static string MapPrimitive(string type)
    {
        var suffix = "";
        // Обработка указателей и массивов (очень простая)
        while (type.EndsWith("*")) { suffix += "*"; type = type[..^1]; }
        while (type.EndsWith("[]")) { suffix += "*"; type = type[..^2]; }

        var mapped = type switch
        {
            "string" => "char*",
            "int" => "int32_t",
            "uint" => "uint32_t",
            "byte" => "uint8_t",
            "bool" => "bool",
            "void" => "void",
            "float" => "float",
            "char" => "char",
            _ => type // Пользовательский тип или уже замангленный
        };
        return mapped + suffix;
    }

    private string GetCName(string name)
    {
        if (IsPrimitive(name)) return MapPrimitive(name);
        return $"{_currentModule}_{name}";
    }
    
    private static bool IsPrimitive(string name) => name is "int" or "float" or "bool" or "void" or "char" or "byte" or "string" or "uint";

    private static string MapOperator(OperatorType op) => op switch
    {
        OperatorType.Plus => "+", OperatorType.Minus => "-", OperatorType.Star => "*", OperatorType.Slash => "/",
        OperatorType.Assign => "=", OperatorType.Equals => "==", OperatorType.NotEquals => "!=",
        OperatorType.Less => "<", OperatorType.Greater => ">", OperatorType.And => "&&", OperatorType.Or => "||",
        _ => ""
    };

    // Utils
    private void EmitNewLine() => _currentSb.AppendLine();
    private void Emit(string s) => _currentSb.AppendLine(new string(' ', _indentLevel * 4) + s);
    private void EmitNoNewLine(string s) => _currentSb.Append(new string(' ', _indentLevel * 4) + s);
    private void Append(string s) => _currentSb.Append(s);
    private void Indent() => _indentLevel++;
    private void Unindent() => _indentLevel--;
}
