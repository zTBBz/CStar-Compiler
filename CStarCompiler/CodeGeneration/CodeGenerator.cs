using CStarCompiler.Parsing.Nodes;
using CStarCompiler.Parsing.Nodes.Modules;

namespace CStarCompiler.CodeGeneration;

using System.Text;

public sealed class CodeGenerator
{
    private int _indentLevel;
    private string _currentModule = null!;
    
    private readonly StringBuilder _sbHeader = new();
    private readonly StringBuilder _sbSource = new();
    private StringBuilder _currentSb = null!;

    public CompilationUnit GenerateUnit(ModuleNode module)
    {
        _sbHeader.Clear();
        _sbSource.Clear();
        _indentLevel = 0;
        _currentModule = module.ModuleName;

        // --- HEADER GENERATION ---
        _currentSb = _sbHeader;
        
        // Header Guards
        var guard = $"{_currentModule.ToUpper()}_H";
        Emit($"#ifndef {guard}");
        Emit($"#define {guard}");
        EmitNewLine();
        
        // Standard Includes in Header
        Emit("#include <stdbool.h>");
        Emit("#include <stdint.h>");
        EmitNewLine();

        // External Imports (Headers)
        foreach (var import in module.Imports)
        {
            if (import.IsCLibrary) Emit($"#include <{import.ModuleName}.h>");
            else Emit($"#include \"{import.ModuleName}.h\"");
        }
        EmitNewLine();

        // Forward Declarations & Typedefs
        Emit("// --- Forward Declarations ---");
        foreach (var decl in module.Declarations)
        {
            if (decl is StructDeclarationNode structNode)
            {
                var cName = GetCName(structNode.Name);
                Emit($"typedef struct {cName} {cName};");
            }
        }
        EmitNewLine();
    
        // Struct Definitions
        Emit("// --- Struct Definitions ---");
        foreach (var decl in module.Declarations)
            if (decl is StructDeclarationNode structNode) GenStruct(structNode);
        
        EmitNewLine();

        // Function Prototypes
        Emit("// --- Prototypes ---");
        foreach (var decl in module.Declarations)
            if (decl is FunctionDeclarationNode funcNode) EmitPrototype(funcNode);
        
        EmitNewLine();
        
        // End Header Guard
        Emit($"#endif // {guard}");
        
        // --- SOURCE GENERATION ---
        _currentSb = _sbSource;

        Emit("// Generated by CStar Compiler");
        Emit($"// Module: {_currentModule}");
        EmitNewLine();
        
        // Standard Libraries needed for implementation
        Emit("#include <stdio.h>");
        Emit("#include <stdlib.h>");
        Emit("#include <string.h>");
        
        // Include own header
        Emit($"#include \"{_currentModule}.h\"");
        EmitNewLine();

        // Global Variables (Definitions)
        Emit("// --- Globals ---");
        foreach (var decl in module.Declarations)
            if (decl is FieldDeclarationNode fieldNode) GenField(fieldNode, isGlobal: true);

        // Function Implementations
        Emit("// --- Implementations ---");
        foreach (var decl in module.Declarations)
            if (decl is FunctionDeclarationNode funcNode) GenFunction(funcNode);

        return new(_currentModule, _sbHeader.ToString(), _sbSource.ToString());
    }

    private void EmitNewLine() => Emit("");
    private void Emit(string line) => _currentSb.AppendLine(new string(' ', _indentLevel * 4) + line);

    private void EmitNoNewLine(string text) => _currentSb.Append(new string(' ', _indentLevel * 4) + text);

    private void Append(string text) => _currentSb.Append(text);
    
    private void GenStruct(StructDeclarationNode node)
    {
        var cName = GetCName(node.Name);
        
        Emit($"struct {cName}");
        Emit("{");
        _indentLevel++;
        
        foreach (var member in node.Members)
        {
            switch (member)
            {
                case FieldDeclarationNode field: GenField(field); break;
                case FunctionDeclarationNode func: GenFunction(func); break;
            }
        }
        
        _indentLevel--;
        Emit("};");
        EmitNewLine();
    }
    
    private void EmitPrototype(FunctionDeclarationNode node)
    {
        Append($"{MapType(node.ReturnType.Type)} {GetCName(node.Name)}(");
        for (var i = 0; i < node.Parameters.Count; i++)
        {
            var param = node.Parameters[i];
            Append($"{MapType(param.Type.Type)} {param.Name}");
            if (i < node.Parameters.Count - 1) Append(", ");
        }
        
        _currentSb.Append(");\n"); // Используем Append напрямую, чтобы избежать отступа в конце строки
    }

    private void GenFunction(FunctionDeclarationNode node)
    {
        EmitNoNewLine($"{MapType(node.ReturnType.Type)} {GetCName(node.Name)}(");
        for (var i = 0; i < node.Parameters.Count; i++)
        {
            var param = node.Parameters[i];
            Append($"{MapType(param.Type.Type)} {param.Name}");
            if (i < node.Parameters.Count - 1) Append(", ");
        }
        
        Append(")");
        _currentSb.AppendLine(); // New line
        
        if (node.Body != null) GenBlock(node.Body);
        else Emit("{ }");
        EmitNewLine();
    }
    
    private void GenField(FieldDeclarationNode node, bool isGlobal = false)
    {
        var type = MapType(node.Type.Type);
        var name = isGlobal ? GetCName(node.Name) : node.Name; // Поля структуры не манглим, глобальные - да

        _currentSb.Append($"{GetIndent()}{type} {name}");

        if (node.Initializer != null)
        {
            _currentSb.Append(" = ");
            GenExpression(node.Initializer);
        }

        _currentSb.Append(';');
        EmitNewLine(); // New line
    }
    
    private void GenBlock(BlockStatementNode block)
    {
        if (block.IsCompileBlock)
        {
            Emit("/* compile block skipped in runtime code */");
            return;
        }

        Emit("{");
        Indent();

        if (block.IsCCode) Emit("// --- CCode Start ---");

        foreach (var stmt in block.Statements) GenStatement(stmt);

        if (block.IsCCode) Emit("// --- CCode End ---");

        Unindent();
        Emit("}");
    }

    private void GenStatement(StatementNode stmt)
    {
        switch (stmt)
        {
            case BlockStatementNode block:
                GenBlock(block);
                break;

            case VarDeclarationNode varDecl:
                var type = varDecl.Type.Type == "var" ? "auto" : MapType(varDecl.Type.Type); 
                // todo: C99 не поддерживает 'auto' для вывода типов. 
                // Для полноценной поддержки 'var' нужен этап TypeInference перед кодогенерацией.
                // Здесь мы заглушим это: если var, то ставим int (или ошибку).
                if (type == "auto") type = "/* var inferred */ int"; 
                
                var constPrefix = varDecl.IsConst ? "const " : string.Empty;
                
                EmitNoNewLine($"{constPrefix}{type} {varDecl.Name}");
                if (varDecl.Initializer != null)
                {
                    _currentSb.Append(" = ");
                    GenExpression(varDecl.Initializer);
                }

                _currentSb.Append(';');
                EmitNewLine();
                break;

            case ReturnStatementNode ret:
                EmitNoNewLine("return");
                if (ret.Value != null)
                {
                    _currentSb.Append(' ');
                    GenExpression(ret.Value);
                }
                _currentSb.Append(';');
                EmitNewLine();
                break;

            case IfStatementNode ifStmt:
                EmitNoNewLine("if (");
                GenExpression(ifStmt.Condition);
                _currentSb.Append(')');
                EmitNewLine();
                GenStatement(ifStmt.ThenBranch);
                if (ifStmt.ElseBranch != null)
                {
                    Emit("else");
                    GenStatement(ifStmt.ElseBranch);
                }
                break;

            case ExpressionStatementNode exprStmt:
                _currentSb.Append(GetIndent());
                GenExpression(exprStmt.Expression);
                _currentSb.Append(';');
                EmitNewLine();
                break;

            default:
                Emit($"// Unknown statement: {stmt.GetType().Name}");
                break;
        }
    }
    
    private void GenExpression(ExpressionNode expr)
    {
        switch (expr)
        {
            case LiteralExpressionNode lit:
                switch (lit.Type)
                {
                    case "string": _currentSb.Append($"\"{lit.Value}\""); break;
                    case "char": _currentSb.Append($"'{lit.Value}'"); break;
                    case "bool": _currentSb.Append((bool)lit.Value ? "true" : "false"); break;
                    default: _currentSb.Append(lit.Value); break;
                }
                break;

            case IdentifierExpressionNode id:
                // Здесь нужно понимать, это локальная переменная или глобальная функция.
                // Для простоты: если имя содержит _, считаем это мангленным именем, иначе оставляем как есть.
                // В реальном компиляторе SymbolTable решает это.
                _currentSb.Append(id.Name); 
                break;

            case BinaryExpressionNode bin:
                GenExpression(bin.Left);
                _currentSb.Append($" {MapOperator(bin.Operator)} ");
                GenExpression(bin.Right);
                break;
            
            case UnaryExpressionNode unary:
                //_currentSb.Append($"({MapOperator(unary.Operator)}");
                _currentSb.Append($"{MapOperator(unary.Operator)}");
                GenExpression(unary.Operand);
                //_currentSb.Append(')');
                break;

            case CallExpressionNode call:
                // Shortcuts (Ident!) -> преобразуем в вызов функции C
                if (call.Callee is IdentifierExpressionNode calleeId)
                {
                     // Пытаемся угадать имя: если это глобальная функция модуля, нужен префикс.
                     // В рамках этого генератора просто печатаем то, что в AST.
                     // Если в AST Name="SumAndPrint<T>", мы должны его почистить.
                     var funcName = GetCName(calleeId.Name);
                     _currentSb.Append(funcName);
                }
                else
                    GenExpression(call.Callee);

                _currentSb.Append('(');
                for (var i = 0; i < call.Arguments.Count; i++)
                {
                    GenExpression(call.Arguments[i]);
                    if (i < call.Arguments.Count - 1) _currentSb.Append(", ");
                }
                _currentSb.Append(')');
                break;

            case MemberAccessExpressionNode member:
                GenExpression(member.Object);
                _currentSb.Append('.'); // Всегда точка, так как CStar data-oriented (структуры). Для указателей нужен ->
                _currentSb.Append(member.MemberName);
                break;
            
            case IndexExpressionNode indexer:
                GenExpression(indexer.Object);
                _currentSb.Append('[');
                GenExpression(indexer.Index);
                _currentSb.Append(']');
                break;

            default:
                _currentSb.Append("/* ? */");
                break;
        }
    }

    private static string MapOperator(OperatorType op)
    {
        return op switch
        {
            OperatorType.Plus => "+",
            OperatorType.Minus => "-",
            OperatorType.Star => "*",
            OperatorType.Slash => "/",
            OperatorType.Percent => "%",
            
            OperatorType.Assign => "=",
            
            OperatorType.NotEquals => "!=",
            OperatorType.Equals => "==",
            
            OperatorType.Less => "<",
            OperatorType.Greater => ">",
            OperatorType.LessOrEqual => "<=",
            OperatorType.GreaterOrEqual => ">=",
            
            OperatorType.And => "&&",
            OperatorType.Or => "||",
            OperatorType.Not => "!",
            
            OperatorType.BitAnd => "&",
            OperatorType.BitOr => "|",
            OperatorType.BitXor => "^",
            OperatorType.BitNot => "~",
            
            OperatorType.Arrow => "LAMBDA", // todo: handle as special case
            _ => throw new ArgumentOutOfRangeException(nameof(op), op, null)
        };
    }
    
    private static string MapType(string type)
    {
        if (string.IsNullOrEmpty(type)) return "void";

        // Базовая обработка дженериков для C: Vector<int> -> Vector_int
        var mapped = type
            .Replace("<", "_")
            .Replace(">", "")
            .Replace(",", "_")
            .Replace(" ", ""); // Vector_int

        return mapped switch
        {
            "string" => "char*",
            "int" => "int32_t",
            "uint" => "uint32_t",
            "byte" => "uint8_t",
            "bool" => "bool",
            _ => mapped
        };
    }

    // Добавляет префикс модуля к глобальным именам (функции, структуры)
    private string GetCName(string name)
    {
        // Если это базовый тип, не меняем
        if (name is "int" or "void" or "bool") return name;

        // Очистка от дженерик символов
        var cleanName = name.Replace("<", "_").Replace(">", "").Replace(",", "_");

        // Если имя уже содержит _, возможно оно уже обработано или системное
        if (cleanName.Contains("_")) return cleanName;

        // Name Mangling: Module_Name
        return $"{_currentModule}_{cleanName}";
    }

    private string GetIndent() => new(' ', _indentLevel * 4);

    private void Indent() => _indentLevel++;
    private void Unindent() => _indentLevel--;
}
